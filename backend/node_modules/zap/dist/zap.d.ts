/// <reference types="node" />
import http from 'http';
import { Stream } from 'stream';
import { URL } from 'url';
export declare type HttpMethod = 'GET' | 'HEAD' | 'POST' | 'PUT' | 'DELETE' | 'OPTIONS' | 'PATCH';
export interface ServerRequest<Params = unknown> extends http.IncomingMessage {
    params: Params;
    protocol: 'http' | 'https';
    parsedURL: URL;
}
export interface ServerResponse extends http.ServerResponse {
}
export declare type ResponseBodyType = string | object | number | Buffer | Stream | Error | null;
export declare type Handler<ResponseBody extends ResponseBodyType = ResponseBodyType, Request extends ServerRequest = ServerRequest> = (req: Request, res: ServerResponse) => void | ResponseBody | Promise<ResponseBody>;
export declare type ErrorHandler = (req: ServerRequest, res: ServerResponse, err: unknown) => void | ResponseBodyType | Promise<ResponseBodyType>;
export interface ServeOptions {
    trustProxy?: boolean;
    errorHandler?: ErrorHandler;
}
export declare function serve(handler: Handler, options?: ServeOptions): (req: http.IncomingMessage, res: http.ServerResponse) => Promise<void>;
export declare function getHeader(req: http.IncomingMessage, header: string): string | undefined;
export interface RequestBodyOptions {
    limit?: string;
    encoding?: string;
}
export declare function buffer(req: http.IncomingMessage, { limit, encoding }?: RequestBodyOptions): Promise<Buffer>;
export declare function text(req: http.IncomingMessage, options?: RequestBodyOptions): Promise<string>;
export declare function json(req: http.IncomingMessage, options?: RequestBodyOptions): Promise<any>;
export declare function send(res: http.ServerResponse, code: number, body?: ResponseBodyType): void;
export declare function notFound(): HttpError;
export declare function router(...handlers: RouteHandler<HttpMethod, any, ResponseBodyType>[]): Handler;
export interface RouteHandler<Method extends HttpMethod = HttpMethod, Route extends string = string, ResponseBody extends ResponseBodyType = ResponseBodyType> extends Handler<ResponseBody, ServerRequest<RouteParams<Route>>> {
    method: Method;
    route: Route;
    compilePath: (params?: RouteParams<Route>) => string;
    matchPath: (path: string) => false | {
        params: RouteParams<Route>;
        path: string;
        index: number;
    };
}
export declare function route<ResponseBody extends ResponseBodyType, Method extends HttpMethod = HttpMethod, Route extends string = string>(method: Method, path: Route, handler: Handler<ResponseBody, ServerRequest<RouteParams<Route>>>): RouteHandler<Method, Route, ResponseBody>;
export declare class HttpError extends Error {
    statusCode: number;
    metadata: unknown;
    constructor(statusCode: number, message: string, metadata: unknown);
}
export declare function httpError(code: number, message: string, metadata?: unknown): HttpError;
export declare class RedirectError extends Error {
    statusCode: number;
    location: string;
    constructor(statusCode: number, location: string);
}
export declare function redirect(location: string, statusCode?: number): RedirectError;
/**
 * Creates a function that caches its results for a given request. Both successful responses
 * and errors are cached.
 *
 * @param fn The function that should be cached.
 * @returns The results of calling the function
 */
export declare function fromRequest<Fn extends (req: ServerRequest, ...rest: any[]) => any>(fn: Fn): Fn;
export declare type RouteParams<T extends string> = T extends `${string}:${infer P}?/${infer Rest}` ? {
    [K in P]?: string;
} & RouteParams<Rest> : T extends `${string}:${infer P}*/${infer Rest}` ? {
    [K in P]?: string[];
} & RouteParams<Rest> : T extends `${string}:${infer P}+/${infer Rest}` ? {
    [K in P]: string[];
} & RouteParams<Rest> : T extends `${string}:${infer P}/${infer Rest}` ? {
    [K in P]: string;
} & RouteParams<Rest> : T extends `${string}:${infer P}?` ? {
    [K in P]?: string;
} : T extends `${string}:${infer P}*` ? {
    [K in P]?: string[];
} : T extends `${string}:${infer P}+` ? {
    [K in P]: string[];
} : T extends `${string}:${infer P}` ? {
    [K in P]: string;
} : {};
//# sourceMappingURL=zap.d.ts.map